#include <chrono>
#include <thread>
#include "./MariosBST.cpp"
#include "queue"
#include <iostream>
#include <sstream>
#include <fstream>
#include <pthread.h>
#include <string>

using std::string;

using namespace std;


// shared queue
vector<opsStruct> commands;

//shared map
EvansMap *evansMap = new EvansMap(750);
MariosBST *mariosBST = new MariosBST();



int EVANS_MAP = 0;
int MARIOS_BST = 1;

// change this to use buffer to read large files
vector<opsStruct> getCommands(string fileName);
float run(int object, string file, string outputFile, bool singleThreaded);  // Changed to float to return time
bool CompareST(string arg1, string arg2);


void* threadFunction(void* args) {
    struct opsStruct *op = (struct opsStruct*) args;
    if (op->object == EVANS_MAP) {
        op->result = evansMap->runOp(op);
    } 
    else {
        op->result = mariosBST->runOp(op);
    }
    return NULL;
}


int main(int argc, char const *argv[])
{
    if (argc != 5) {
        cout << "./userinterface has format: <inputfile.txt> <outputfile.txt> <0/1> <0/1>\n" 
        <<  "where <0/1> = <hashmap/BST>, and <0/1> = <don't/do compare to single threaded>, respectively." << endl;
        return -1;
    }

    // get the file name from the command line
    string inputFile = argv[1];
    string outputFile = argv[2];
    int structure = std::stoi(argv[3]);  // 0 = Hashmap, 1 = BST
    int compSingleThreaded = std::stoi(argv[4]);  // 0 = Don't, 1 = Do compare performance to single threaded version
    if (structure != 1 && structure != 0)
        structure = 0;
    if (compSingleThreaded != 1 && compSingleThreaded != 0)
        compSingleThreaded = 0;

    // run the program 
    // Added singleThreaded boolean for testing purposes (default = false)
    if (compSingleThreaded == 0) {
        run(structure, inputFile, outputFile, false);
    } else {
        float t1 = run(structure, inputFile, "ST_" + outputFile, true);  // Single-threaded (baseline)

        // Need a way to clear the data structure completely for this to work
        
        float t2 = run(structure, inputFile, outputFile, false);  // Based on input (possibly multi-threaded)
        CompareST(outputFile, ("ST" + outputFile));
        float percent = (t1/t2 * 100) - 100;
        if (percent < 0)
            percent *= -1;
        cout << "Test was " << percent << "% " << (t1 > t2 ? "faster" : "slower") << " than the single-threaded version" << endl;
    }
    return 0;
}

// Compares output file with expected output
// File must have accompanying test_expected.txt file generated by FileGenerator.cpp!!
bool CompareST(string arg1, string arg2) {
    ifstream file1(arg1);
    ifstream file2(arg2);
    int count = 1;
    string compare1, compare2;
    while (file1.good()) {
        file1 >> compare1;
        file2 >> compare2;
        if (compare1 != compare2) {
            cout << "[FAIL]\n" << arg1 << " produced: " << compare1 <<
            "\nBut expected: " << compare2 << "\nAt string " << count << endl;
            return false;
        }
        count++;
    }
    file1.close();
    file2.close();
    cout << "[SUCCESS]\n<" << arg1 << "> and <" << arg2 << "> match." << endl;
    return true;
}

// run the program with a given object inputfile and outputfile
// will read the input file and run the commands with the number of specified threads
// will write the output to the output file
float run(int object, string file, string outputFile, bool singleThreaded) {
    // get the commands from the file
    commands = getCommands(file);
    int opsIndex = 0;

    int maxNumThreads;
    if (!singleThreaded)
        maxNumThreads = commands[opsIndex].key;
    else
        maxNumThreads = 1;
        
    commands[opsIndex].result = "Using " + to_string(commands[opsIndex].key) + " threads";
    commands[opsIndex].object = object;
    opsIndex++;


    // while there are still commands to run
    // create a thread for each command for the max number of threads
    // then join the threads
    // time this
    auto start = std::chrono::high_resolution_clock::now();
    while(opsIndex < commands.size()) {
        int commandsLeft = commands.size() - opsIndex;
        int numThreads = commandsLeft < maxNumThreads ? commandsLeft : maxNumThreads;

        // threads to use
        pthread_t threads[numThreads];

        for (int i = 0; i < numThreads; i++) {
            commands[opsIndex].object = object;
            pthread_create(&threads[i], NULL, &threadFunction, (void *) &commands[opsIndex]);
            // sleep for 1 microsecond to allow the threads to be created
            std::this_thread::sleep_for(std::chrono::microseconds(1));
            opsIndex++;
        }

        for (int i = 0; i < numThreads; i++) {
            pthread_join(threads[i], NULL);
        }

    }
    auto finish = std::chrono::high_resolution_clock::now();

    // get the time
    std::chrono::duration<double> elapsed = finish - start;
    cout << "Elapsed time for " << maxNumThreads << " thread" << (maxNumThreads == 1 ? ": " : "s: ") << elapsed.count() << " s" << endl;

    // write to outputFile
    ofstream out;
    out.open(outputFile, ios::out);
    for (int i = 0; i < commands.size(); i++) {
        // cout << commands[i].result << endl;
        out << commands[i].result << endl;
    }
    out.close();

    // clear the commands
    commands.clear();

    return elapsed.count();
}

// reads in a file with commands to be added to a global queue
// will change to use a buffer to handle files larger than memory
vector<opsStruct> getCommands(string fileName) {
    vector<opsStruct> commands;
    std::ifstream in(fileName);
    string line = "";
    if (in.is_open()) {
        while (getline(in, line)) {
            char c = line[0];
            int space1 = line.find(" ");
            int space2 = line.find(" ", space1 + 1);

            int key;
            string value;
            // check if there is a second space
            if (space2 != -1) {
                key = stoi(line.substr(space1 + 1, space2 - space1 - 1));

                string badValue = line.substr(space2 + 1);
                // remove the quotes around the value
                // value = value.substr(1, value.length() - 2);
                // remove the first and last character
                // value = value.substr(1, value.length() - 2);
                for (int i = 1; i < badValue.length() - 1; i++) {
                    value += badValue[i];
                }
                // cout << "value: " << value << endl;
            } else {
                key = stoi(line.substr(space1 + 1));
                value = "";
            }
            opsStruct op = {c, key, value};
            commands.push_back(op);
        }
    } else {
        cout << "Unable to open file" << endl;
    }
    in.close();
    return commands;
}

